<!DOCTYPE html><html><head><meta charset="utf-8"><title>CJDI_SpringBoot_Demo.md</title><script type="text/javascript">
//<![CDATA[
window.__cfRocketOptions = {byc:0,p:0,petok:"4f24b4e8dc6d58d27ab2dcbe3d126d7588a88df4-1523539190-1800"};
//]]>
</script>
<script type="text/javascript" src="https://ajax.cloudflare.com/cdn-cgi/scripts/935cb224/cloudflare-static/rocket.min.js"></script>
<style></style></head><body id="preview">
<h1><a id="Introduction_0"></a>Introduction</h1>
<p>The intent of this sample code is to show how to use CASR/CJDI diameter as a library from a non OSGi environment. In this context, the sample provides two applications based on SpringBoot.</p>
<ul>
<li>com.nokia.casr.samples.diameter.springboot.server: this is a springboot application providing a CJDI server proxylet that is defined without using OSGi.</li>
<li>com.nokia.casr.samples.diameter.springboot.client: another springboot application used to send diameter requests to the diameter server. As in the first application, the code is defined without using OSGi. The application also uses springboot web starter in order to control the application using HTTP/REST. The client also shows how to do integration (junit) tests easily using spring boot test starter and CJDI diameter client API.</li>
</ul>
<h1><a id="Prerequisites_5"></a>Prerequisites</h1>
<p>Maven must be installed, and the 8080 port must not be already listened.</p>
<h1><a id="Architecture_8"></a>Architecture</h1>
<p>SpringBoot support the concept of “starters”. a SpringBoot starter allows to embed in your springboot application the necessary dependencies for a given feature by simply adding one maven dependeny in your pom (or you gradle) project. For example, if your application needs to support REST services, you would add this single dependency in your application:</p>
<pre><code class="language-sh">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>Similarly, to be able to use CJDI in a springboot application and embed all the necessary CASR/CJDI dependencies, you also need to declare a CJDI starter. But before declaring such starter, you must first create one. To do so, we provide a maven “archetype” which you can use to generate your own CJDI starter.</p>
<p>A Maven archetype is a kind of template that is deployed to artifactory and it can be used to bootstrap a new maven (or gradle, anything actually) project from scratch.</p>
<p>So, you need to run the archetype command by passing some arguments which will tell what CJDI components must be included in your CJDI starter. Indeed, CJDI is component based and we don’t provide a mega jar; instead you must select the features you want and a CJDI OSGi runtime is then generated with the features you have selected. For example, for the support of Diameter, you would select the following features:</p>
<ul>
<li>runtime.felix.embedded.log4j1: this feature regroups the dependencies for Apache Felix OSGi framework, and log4j1 support.</li>
<li>ioh.mux.diameter: this feature regroups the dependencies for the CJDI Diameter IO Handler</li>
<li>agent.proxylet.diameter: this feature regroups the dependencies for the CJDI Diameter Proxylet Engine.</li>
</ul>
<p>More features could be added like for example the support of Prometheus metrics, CSF/Kafka CSF/Service Discovery (etcd4j), etc …<br>
For the moment, let’s use the minimal features (felix +  diameter ioh + diameter proxylet engine).<br>
So, once you have created your CJDI starter, you can then embed it in your springboot application.</p>
<p>Now, how to interact with the CJDI OSGi runtime ? This is done using CJDI “OSGi bridge” service, which allows you to obtain OSGi services from springboot class loader, and/or register your proxylets from springboot to CJDI OSGi Runtime. The interface for this service looks like the following:</p>
<pre><code class="language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OsgiLauncher</span> </span>{
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">ServiceRegistration&lt;T&gt; <span class="hljs-title">registerService</span><span class="hljs-params">(Class&lt;T&gt; service, T implementation)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">CompletableFuture&lt;T&gt; <span class="hljs-title">getService</span><span class="hljs-params">(Class&lt;T&gt; service)</span></span>;
    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">CompletableFuture&lt;T&gt; <span class="hljs-title">getService</span><span class="hljs-params">(Class&lt;T&gt; service, String filter)</span></span>;
    ...
}
</code></pre>
<p>Now, when your springboot application defines a dependency on the CJDI springboot starter, it is then able to be injected with the OsgiLauncher “bridge” service. Here is an example of a springboot REST controler which is getting the CJDI DiameterClientFactory osgi service using the OsgiLauncher service:</p>
<pre><code class="language-java"><span class="hljs-annotation">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiameterLoaderController</span> </span>{

    <span class="hljs-comment">/**
     * This service is the bridge between springboot world and CJDI osgi world.
     * Using this service, you can then obtain CASR services, or register your
     * springboot classes as osgi services.
     */</span>
    <span class="hljs-annotation">@Autowired</span>
    <span class="hljs-keyword">private</span> OsgiLauncher _launcher;
    
    <span class="hljs-annotation">@RequestMapping</span>(<span class="hljs-string">"/start"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>{
        CompletableFuture&lt;DiameterClientFactory&gt; dcf = _launcher.getService(DiameterClientFactory.class);
        DiameterClientFactory factory = dfc.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);
        ...
    }
}
</code></pre>
<h1><a id="Creating_a_CJDI_SpringBoot_starter_63"></a>Creating a CJDI SpringBoot starter</h1>
<p>So, to create your CJDI springboot starter, you must invoke the CJDI springboot starter archtetype. But before, you must make sure your maven settings are properly configured in order to be able to download artifacts from maven central as well as from the CSF artifactory: this artifactory provides all CJDI artifacts.<br>
Please add this section in your ~/.m2/settings.xml; to enable mirroring of the csf-mvn-delivered repository:</p>
<pre><code class="language-sh">&lt;settings&gt;
    &lt;mirrors&gt;
      &lt;mirror&gt;
    &lt;id&gt;csf&lt;/id&gt;
    &lt;name&gt;csf delivered&lt;/name&gt;
    &lt;url&gt;http://repo.lab.pl.alcatel-lucent.com/csf-mvn-delivered&lt;/url&gt;
    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
      &lt;/mirror&gt;
    &lt;/mirrors&gt;

&lt;/settings&gt;
</code></pre>
<p>And now you can invoke the following maven command that will invoke the CJDI archetype to generate your own CJDI starter:</p>
<pre><code class="language-sh">mvn archetype:generate -U  -B \
    -Dobr=http://repo.lab.pl.alcatel-lucent.com/csf-mvn-delivered/com/nokia/casr/com.nokia.casr.obr/<span class="hljs-number">18.10</span>.<span class="hljs-number">2</span>/com.nokia.casr.obr-<span class="hljs-number">18.10</span>.<span class="hljs-number">2</span>.xml \
    -DarchetypeGroupId=com.nokia.casr \
    -DarchetypeArtifactId=com.nokia.as.archetype.springboot.starter \
    -DarchetypeCatalog=<span class="hljs-built_in">local</span> \
    -DarchetypeVersion=<span class="hljs-number">1.0</span>.<span class="hljs-number">1</span> \
    -DgroupId=com.nokia.casr.samples.diameter.springboot \
    -DartifactId=com.nokia.casr.samples.diameter.springboot.starter \
    -Dversion=<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span> \
    -Dfeatures=runtime.felix.embedded.log4j1,ioh.mux.diameter,agent.proxylet.diameter
</code></pre>
<p>So, in the above command, you have specified the G.A.V for your new starter (both client and server will depend on it), as well as the needed CJDI features:</p>
<ul>
<li>-DgroupId=com.nokia.casr.samples.diameter.springboot: this is the group id of the CJDI starter you are creating</li>
<li>-DartifactId=com.nokia.casr.samples.diameter.springboot.starter: this is the artifactId of the CJDI starter you are creating</li>
<li>-Dversion=1.0.0: this is the version of the CJDI starter you are creating</li>
<li>-Dfeatures=runtime.felix.embedded.log4j1,ioh.mux.diameter,agent.proxylet.diameter: this is the CJDI minimal features for support of diameter</li>
</ul>
<h1><a id="Build_the_generated_CJDI_starter_100"></a>Build the generated CJDI starter</h1>
<p>now we have generated the CJDI starter, let’s build it:</p>
<pre><code class="language-sh"><span class="hljs-built_in">cd</span> com.nokia.casr.samples.diameter.springboot.starter
mvn clean dependency:copy install
</code></pre>
<p>Notice that the ‘dependency:copy’ option is needed because we need to embed in the target starter jar all the CJDI dependencies.</p>
<h1><a id="Build_the_springboot_sample_server_108"></a>Build the springboot sample server</h1>
<p>Now we have generated and built our CJDI starter, we can now build the springboot diameter server.<br>
The server pom is already importing the CJDI starter we have generated:</p>
<pre><code class="language-sh">        &lt;dependency&gt;
            &lt;groupId&gt;com.nokia.casr.samples.diameter.springboot&lt;/groupId&gt;
            &lt;artifactId&gt;com.nokia.casr.samples.diameter.springboot.starter&lt;/artifactId&gt;
            &lt;version&gt;<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<p>So, now let’s build the server:</p>
<pre><code class="language-sh"><span class="hljs-built_in">cd</span> com.nokia.casr.samples.diameter.springboot.server
mvn clean install
</code></pre>
<h1><a id="Start_the_diameter_server_124"></a>Start the diameter server</h1>
<p>The configuration is already pre configured in the ./conf directory.<br>
So, you can now start the server like this:</p>
<pre><code class="language-sh"><span class="hljs-built_in">cd</span> com.nokia.casr.samples.diameter.springboot.server
java -Das.config.file.confdir=conf -jar target/com.nokia.casr.samples.diameter.springboot.server-<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>.jar
</code></pre>
<p>Notice the -Das.config.file.confdir that is passed as argument: it must point the CJDI configuration directory.<br>
Internal CJDI diameter container logs are genereted in var/log/csf.group__component.instance/msg.log, but standard output is displayed on your console.</p>
<p>Interesting configuration files are</p>
<ul>
<li>conf/log4j.properties (used to configure log4j)</li>
<li>conf/diameter-pxlets.xml (used to declare your diameter proxylets)</li>
<li>conf/defDiameterTcpServer.txt (used to configure diameter listening addresses)</li>
</ul>
<h1><a id="Build_the_spring_diameter_client_application_139"></a>Build the spring diameter client application</h1>
<p>From another console, you now have to build the application that will send requests to the server.<br>
The client application also contains an integration (junit) test which will try to send requests to the server. <code>So make sure the server is running before building the client.</code><br>
You can build the client like this:</p>
<pre><code class="language-sh"><span class="hljs-built_in">cd</span>  com.nokia.casr.samples.diameter.springboot.client
mvn -DargLine=<span class="hljs-string">"-Das.config.file.confdir=conf"</span> clean install
</code></pre>
<p>You should see the traces displayed by the junit integration test:</p>
<pre><code class="language-text">2018-03-22 15:26:39.600  INFO 4144 --- [           main] c.n.c.s.d.s.client.DiameterLoaderTest    : Started DiameterLoaderTest in 6.354 seconds (JVM running for 7.297)
test: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="abc7cadec5c8c3ced996c8c4c685c5c4c0c2ca85cad885c4d8ccc285c7cadec5c8c3ced985c2c6dbc785e4d8ccc2e7cadec5c8c3ced9e2c6dbc7eb9ecdc993cfc8">[email&#160;protected]</a>01
DiameterLoader: starting
TestClient : connected
handleResponse : response = DiameterResponse [
        Application-Id = 0x7b
        Command=1 (1)
        Flags=-
        HopByHop Identifier (client-side) = 7340033
        HopByHop Identifier (server-side) = 7340033
        EndToEnd Identifier = -344981502
        Reception Address = /127.0.0.1:55718
        DiameterAVP [code=263, name=Session-Id, vendorId=0,flags#0=-M-,value#0:UTF8String=&quot;client.nokia.com;3730717598;0;client&quot;]
        DiameterAVP [code=264, name=Origin-Host, vendorId=0,flags#0=-M-,value#0:Identity=testserver.nokia.com]
        DiameterAVP [code=296, name=Origin-Realm, vendorId=0,flags#0=-M-,value#0:Identity=nokia.com]
        DiameterAVP [code=260, name=Vendor-Specific-Application-Id, vendorId=0,flags#0=-M-,value#0:GroupedAVP={
          AVP#0=DiameterAVP [code=266, name=Vendor-Id, vendorId=0,flags#0=-M-,value#0:Unsigned32=10415],
          AVP#1=DiameterAVP [code=259, name=Acct-Application-Id, vendorId=0,flags#0=-M-,value#0:Unsigned32=123]}]
        DiameterAVP [code=268, name=Result-Code, vendorId=0,flags#0=-M-,value#0:Unsigned32=2001]
        DiameterAVP [code=1, name=User-Name, vendorId=0,flags#0=-M-,value#0:UTF8String=&quot;HelloWorld 1&quot;]
        DiameterAVP [code=99, name=&lt;???&gt;, vendorId=10415
          flags#0=V--,value#0:OctetString(Binary)=[0x00('?'), 0x00('?'), 0x00('?'), 0x01('?')]
          flags#1=V--,value#1:OctetString(Binary)=[0x00('?'), 0x00('?'), 0x00('?'), 0x02('?')]]
]
Received 1 responses
</code></pre>
<h1><a id="Start_the_diameter_client_application_176"></a>Start the diameter client application</h1>
<p>Now you can start the diameter client application: it won’t send requests until you hit &quot;<a href="http://localhost:8080/start">http://localhost:8080/start</a>&quot; (there is also a springboot web starter in the client):</p>
<pre><code class="language-sh"><span class="hljs-built_in">cd</span> com.nokia.casr.samples.diameter.springboot.client
java -Das.config.file.confdir=conf -jar target/com.nokia.casr.samples.diameter.springboot.client-<span class="hljs-number">1.0</span>.<span class="hljs-number">0</span>.jar
</code></pre>
<p>Like in the server, the CJDI internal logs are generated to var/log/csf.group__component.instance/msg.log, but standard output is displayed on your console.</p>
<h1><a id="Connect_to_the_diameter_client_using_your_brower_185"></a>Connect to the diameter client using your brower</h1>
<p>Now, to let the client application start loading the server, simply go to this url:</p>
<pre><code class="language-sh">http://localhost:<span class="hljs-number">8080</span>/start
</code></pre>
<p>You should now see traces displayed on both server console, as well as on client console.<br>
And to ask the client to stop loading the server, go to this url:</p>
<pre><code class="language-sh">http://localhost:<span class="hljs-number">8080</span>/stop
</code></pre>

<script data-cfasync="false" src="/cdn-cgi/scripts/d07b1474/cloudflare-static/email-decode.min.js"></script></body></html>
