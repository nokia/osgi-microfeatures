// Copyright 2000-2021 Nokia
//
// Licensed under the Apache License 2.0
// SPDX-License-Identifier: Apache-2.0
//

package com.nokia.licensing.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.StringTokenizer;

import javax.xml.crypto.XMLStructure;
import javax.xml.crypto.dom.DOMStructure;
import javax.xml.crypto.dsig.XMLSignature;
import javax.xml.crypto.dsig.XMLSignatureFactory;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.keyinfo.X509IssuerSerial;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.*;
import org.xml.sax.SAXException;

import com.nokia.licensing.dtos.FeatureInfo;
import com.nokia.licensing.dtos.StoredLicense;
import com.nokia.licensing.dtos.TargetSystem;
import com.nokia.licensing.interfaces.LicenseException;
import com.nokia.licensing.logging.LicenseLogger;


/**
 *
 * @author chhgupta This Program is used to parse a Licence file generated by CLics using Xerces DOM parser. It
 *         generates a StoredLicence object after parsing the Licence file.
 *
 */
public class LicenseXMLParser {

	/**
	 * This method parses the FileInputStream
	 *
	 * @param fname
	 *            - The FileInputStream to be parsed Calls parseXmlFile method
	 * @return StoredLicence instance
	 * @throws SAXException
	 * @throws DOMException
	 * @throws LicenseException
	 *
	 */
	public StoredLicense parse(final InputStream inputStream) throws DOMException, SAXException, LicenseException {
		final StoredLicense storedLicense = parseXmlFile(inputStream);
		return storedLicense;
	}

	/**
	 * This method obtains a DocumentBuilder from a DocumentBuilderFactory. Creates a Document by parsing the
	 * DocumentBuilder instance. Calls method parseDocument which returns an instance of StoredLicence
	 *
	 * @param fname
	 *            - instance of FileInputStream
	 * @return - an instance of StoredLicence
	 * @throws DOMException
	 * @throws SAXException
	 * @throws LicenseException
	 */
	private StoredLicense parseXmlFile(final InputStream inputStream)
			throws DOMException, SAXException, LicenseException {

		/*
		 * //Validate License file against the xsd schema. SchemaFactory schemaFactory = SchemaFactory.newInstance(
		 * XMLConstants.W3C_XML_SCHEMA_NS_URI ); Schema schemaXSD = schemaFactory.newSchema( new
		 * File("licence-schema_210.xsd")); Validator validator = schemaXSD.newValidator();
		 */

		// get a new instance from the factory
		final DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

		try {

			// Using factory get an instance of document builder
			final DocumentBuilder db = dbf.newDocumentBuilder();

			/*
			 * // parse the XML purely as XML and get a DOM tree represenation. Document document =
			 * db.parse(fileInputStream);
			 *
			 * // parse the XML DOM tree againts the stricter XSD schema validator.validate( new DOMSource(document));
			 */

			// parse using builder to get DOM representation of the XML file
			final Document dom = db.parse(inputStream);

			// get each License element and create a License object
			final StoredLicense storedLicense = parseDocument(dom);

			return storedLicense;
		} catch (final ParserConfigurationException pce) {
			LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile",
					"Validation against xml-schema is failed." + pce.getMessage());
			throw new LicenseException("CLJL117", "Configuratin exception");
		} catch (final IOException ioe) {
			LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile",
					"Validation against xml-schema is failed." + ioe.getMessage());
			throw new LicenseException("CLJL116", "IO exception");
		}
		// }catch (LicenseException e) {
		// LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile", e.getMessage());
		// return null;
		// }
	}

	/**
	 * This method obtains the Root Element and then fetches the Elements that exist under it.
	 *
	 * @param dom
	 *            - Document instance
	 * @return - an instance of StoredLicence
	 */
	private StoredLicense parseDocument(final Document dom) throws LicenseException {

		// get the root element
		final Element licenseElement = dom.getDocumentElement();
		final NodeList licenceDataNode = licenseElement.getElementsByTagName(LicenseConstants.LICENSEDATA);
		final Element licenseDataElement = (Element) licenceDataNode.item(0);
		final StoredLicense storedLicense = getLicense(licenseDataElement);
		return storedLicense;
	}

	public String displayElement(Element elements1){
		try
		{
			// Set up the output transformer
			TransformerFactory transfac = TransformerFactory.newInstance();
			Transformer trans = transfac.newTransformer();
			trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
			trans.setOutputProperty(OutputKeys.INDENT, "yes");
			// Print the DOM node
			StringWriter sw = new StringWriter();
			StreamResult result = new StreamResult(sw);
			DOMSource source = new DOMSource(elements1);
			trans.transform(source, result);
			String xmlString = sw.toString();
			return xmlString;
		}
		catch (TransformerException e)
		{
			e.printStackTrace();
		}
		return "NO DATA";
	}

	/**
	 * This method takes a LicenseData element and reads the values in, creates a StoredLicence object and returns it
	 *
	 * @param element1
	 *            - Root Element in the License file ,i.e., LicenseData
	 * @return - StoredLicence
	 */
	private StoredLicense getLicense(final Element element1) throws LicenseException {
		final StoredLicense storedLicense = new StoredLicense();
		String licenceCode = "";
		String licenceName = "";
		String orderId = "";
		String serialNbr = "";
		String customerId = "";
		String customerName = "";
		String targetNEType = null;
		TargetSystem targetSystem; // = null;
		Date startTime = null;
		Date endTime = null;
		long maxValue;

		String maxValueString = null;
		try {

			NodeList signatureNodeList= element1.getElementsByTagNameNS(XMLSignature.XMLNS, "Signature");//element1.getElementsByTagName("X509IssuerName");
			final ArrayList<TargetSystem> targetIds = new ArrayList<TargetSystem>();
			final NodeList licenseInfoNode = element1.getElementsByTagName(LicenseConstants.LICENSEINFO);
			final Element licenseInfoElement = (Element) licenseInfoNode.item(0);

			licenceCode = licenseInfoElement.getAttribute(LicenseConstants.LICENSECODE);
			licenceName = licenseInfoElement.getAttribute(LicenseConstants.LICENSENAME);

			final NodeList orderNode = element1.getElementsByTagName(LicenseConstants.ORDER);
			final Element orderElement = (Element) orderNode.item(0);
			final String retrivedOrderId = orderElement.getAttribute(LicenseConstants.ORDERID);

			if (retrivedOrderId.equals("") || (retrivedOrderId == null)) {
				orderId = null;
			} else {
				orderId = retrivedOrderId;
			}

			final NodeList serialNode = element1.getElementsByTagName(LicenseConstants.SERIAL);
			final Element serialElement = (Element) serialNode.item(0);

			serialNbr = serialElement.getAttribute(LicenseConstants.SERIALNBR);

			final NodeList customerNode = element1.getElementsByTagName(LicenseConstants.CUSTOMER);
			final Element customerElement = (Element) customerNode.item(0);

			customerId = customerElement.getAttribute(LicenseConstants.CUSTOMERID);
			customerName = customerElement.getAttribute(LicenseConstants.CUSTOMERNAME);

			final NodeList thresholdNode = element1.getElementsByTagName(LicenseConstants.THRESHOLD);
			final Element thresholdElement = (Element) thresholdNode.item(0);
			final NodeList objectLimitNode = thresholdElement.getElementsByTagName(LicenseConstants.OBJECTLIMIT);

			if (objectLimitNode.getLength() != 0) {
				final Element objectLimitElement = (Element) objectLimitNode.item(0);
				maxValueString = objectLimitElement.getAttribute(LicenseConstants.MAXVALUE);
				// Max value is the capacity
			} else {
				maxValueString = "0";
			}

			final NodeList timeLimitNode = thresholdElement.getElementsByTagName(LicenseConstants.TIMELIMIT);
			final Element timeLimitElement = (Element) timeLimitNode.item(0);
			final String startTimeString = timeLimitElement.getAttribute(LicenseConstants.STARTTIME);

			/*
			 * Putting try block for values which are optional and hence can be null
			 */
			try {
				String endTimeString = "";
				final DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");

				endTimeString = timeLimitElement.getAttribute(LicenseConstants.ENDTIME);

				if ((endTimeString != "") && (endTimeString != null)) {
					endTime = df.parse(endTimeString);
					storedLicense.setEndTime(endTime);
				} else {

					/*
					 * Date defaultEndTime = new Date(Long.valueOf(pref.get("defaultEndTime" ,"2000000000000"))); String
					 * defaultEndTimeString = df.format(defaultEndTime); defaultEndTime =
					 * df.parse(defaultEndTimeString); storedLicense.setEndTime(defaultEndTime);
					 */
					storedLicense.setEndTime(null);
				}
			} catch (final ParseException pe) {
				LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile", "ParseException:" + pe.getMessage());
			} catch (final NullPointerException ne) {
			}

			final DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");

			try {
				startTime = df.parse(startTimeString);
			} catch (final ParseException e) {
				e.printStackTrace();
			}

			final NodeList targetNode = element1.getElementsByTagName(LicenseConstants.TARGET);

			if ((targetNode != null) && (targetNode.getLength() > 0)) {
				LicenseLogger.getInstance().finest(this.getClass().getName(), "getLicense", "Target tag is available");

				final Element targetElement = (Element) targetNode.item(0);

				targetNEType = targetElement.getAttribute(LicenseConstants.TARGETNETYPE);

				final NodeList targetNeNode = targetElement.getElementsByTagName(LicenseConstants.TARGETNE);

				if ((targetNeNode != null) && (targetNeNode.getLength() > 0)) {
					for (int i = 0; i < targetNeNode.getLength(); i++) {
						final Element targetNeElement = (Element) targetNeNode.item(i);

						try {
							final String targetIdString = targetNeElement.getAttribute(LicenseConstants.TARGETID);

							targetSystem = new TargetSystem();
							targetSystem.setTargetId(targetIdString);
							targetIds.add(targetSystem);
						} catch (final NullPointerException ne) {
						}
					}
				}
			}

			storedLicense.setFeatureInfoList(parseFeatureInfoNode(element1));

			NodeList supplementaryInfoNode;
			Element supplementaryInfoElement;
			String licenceType;
			String usageType;
			String capacityUnit;
			String additionalInfo = null;
			String originOMC = null;
			String pool = null;

			supplementaryInfoNode = element1.getElementsByTagName(LicenseConstants.SUPPLEMENTARYINFO);
			supplementaryInfoElement = (Element) supplementaryInfoNode.item(0);

			if (supplementaryInfoElement == null) {

				// Its a NE license
				storedLicense.setLicenseType(StoredLicense.LicenseType.NE);

				if (objectLimitNode.getLength() == 0) {
					storedLicense.setLicenseMode(StoredLicense.LicenseMode.ONOFF);
				} else {
					storedLicense.setLicenseMode(StoredLicense.LicenseMode.CAPACITY);
				}
			} else {
				licenceType = supplementaryInfoElement.getAttribute(LicenseConstants.LICENSETYPE);
				usageType = supplementaryInfoElement.getAttribute(LicenseConstants.USAGETYPE);
				capacityUnit = supplementaryInfoElement.getAttribute(LicenseConstants.CAPACITYUNIT);
				additionalInfo = supplementaryInfoElement.getAttribute(LicenseConstants.ADDITIONALINFO);

				if (signatureNodeList != null  && signatureNodeList.getLength() > 0 && signatureNodeList.item(0).getNodeValue().contains("LICENSESIGNER")){
					additionalInfo = null;
					originOMC = null;
					pool = null;
				} else {
					if ((additionalInfo == null) || "".equals(additionalInfo)) {
						additionalInfo = null;
						originOMC = null;
						pool = null;
					} else {
						if (additionalInfo.startsWith("ASLM=")){
							originOMC = null;
							pool = null;
						} else {
							final StringTokenizer temp = new StringTokenizer(additionalInfo, ",");

							while (temp.hasMoreTokens()) {
								final StringTokenizer temp1 = new StringTokenizer(temp.nextToken(), "=");

								if (temp1 != null) {
									final String key = temp1.nextToken().trim();
									final String value = temp1.nextToken().trim();

									if (key.equalsIgnoreCase("originOMC")) {
										originOMC = value;
									} else if (key.equalsIgnoreCase("pool")) {
										pool = value;
									}
								}
							}
						}
					}
				}

				// To decide whether it is pool or ne license/ whether mode is
				// ON/OFF or CAPACITY.
				if (licenceType != null) {
					if ((originOMC == null) && (pool == null)) {
						if (isFloating(usageType)) {
							storedLicense.setLicenseType(StoredLicense.LicenseType.FLOATING_POOL);
						} else {
							storedLicense.setLicenseType(StoredLicense.LicenseType.POOL);
						}
					} else {
						if (isFloating(usageType)) {
							storedLicense.setLicenseType(StoredLicense.LicenseType.FLOATING_NMS);
						} else {
							storedLicense.setLicenseType(StoredLicense.LicenseType.NMS);
						}
					}

					final StoredLicense.LicenseMode temp = licenceType.equalsIgnoreCase("capacity")
							? StoredLicense.LicenseMode.CAPACITY : StoredLicense.LicenseMode.ONOFF;

					storedLicense.setLicenseMode(temp);
				} else {
					storedLicense.setLicenseType(StoredLicense.LicenseType.NE);

					if (objectLimitNode.getLength() == 0) {
						storedLicense.setLicenseMode(StoredLicense.LicenseMode.ONOFF);
					} else {
						storedLicense.setLicenseMode(StoredLicense.LicenseMode.CAPACITY);
					}
				}

				storedLicense.setUsageType(usageType);
				storedLicense.setCapacityUnit(capacityUnit);
				storedLicense.setAdditionalInfo(additionalInfo);
				storedLicense.setOriginOMC(originOMC);
				storedLicense.setPool(pool);
			}

			// storedLicense.setAdditionalInfo();
			storedLicense.setCustomerId(customerId);
			storedLicense.setCustomerName(customerName);
			storedLicense.setLicenseCode(licenceCode);
			storedLicense.setLicenseName(licenceName);
			storedLicense.setOrderId(orderId);

			// maxValue = Integer.valueOf(maxValueString).intValue();
			try {
				maxValue = Long.valueOf(maxValueString).longValue();
			} catch (final NumberFormatException nfe) {
				LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile", "NumberFormatException", nfe);
				throw new LicenseException("CLJL101", "NumberFormatException");
			}
			storedLicense.setMaxValue(maxValue);

			// storedLicense.setEndTime(endTime);
			storedLicense.setStartTime(startTime);			
			storedLicense.setSerialNbr(serialNbr);
			storedLicense.setTargetNEType(targetNEType);
			storedLicense.setTargetIds(targetIds);
		} catch (final LicenseException le) {
			throw le;
		} catch (final RuntimeException rte) {
			LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile", "Unknown exception", rte);
			throw new LicenseException("CLJL101", "Unknown exception while parsing license");
		}
		System.out.println("#!#!#!#!#!#!#!#!#!#!#!#!#!#!#!   License succesfully parsed");
		return storedLicense;
	}

	private List<FeatureInfo> parseFeatureInfoNode(final Element element1)	throws LicenseException {
		
		final List<FeatureInfo> featureInfoList = new ArrayList<FeatureInfo>();
		final NodeList featureInfoNode = getFeatureInfoNode(element1);
		if(featureInfoNode != null) {
			for (int i = 0; i < featureInfoNode.getLength(); i++) {
				final Element featureInfoElement = (Element) featureInfoNode.item(i);
				final FeatureInfo featureInfo = parseFeatureInfoElement(featureInfoElement);
				featureInfoList.add(featureInfo);
			}
		}
		
		return featureInfoList;
	}

	private FeatureInfo parseFeatureInfoElement(final Element featureInfoElement) throws LicenseException {
		final FeatureInfo featureInfo = new FeatureInfo();
		final String featureCodeString = featureInfoElement.getAttribute(LicenseConstants.FEATURECODE);		
		try {				
			featureInfo.setFeatureCode(Long.valueOf(featureCodeString).longValue());
		} catch (final NumberFormatException nfe) {
			LicenseLogger.getInstance().error(this.getClass().getName(), "parseXmlFile", "NumberFormatException", nfe);
			throw new LicenseException("CLJL101", "NumberFormatException");
		}			
		featureInfo.setFeatureName(featureInfoElement.getAttribute(LicenseConstants.FEATURENAME));
		return featureInfo;
	}

	private NodeList getFeatureInfoNode(final Element element1) {
		final Element featureDataElement = getFeatureDataElement(element1);
		if (featureDataElement != null) {
			return featureDataElement.getElementsByTagName(LicenseConstants.FEATUREINFO);
		}
		return null;
	}

	private Element getFeatureDataElement(final Element element1) {
		final NodeList featureDataNode = element1.getElementsByTagName(LicenseConstants.FEATUREDATA);
		if(featureDataNode != null){
			return (Element) featureDataNode.item(0);
		}
		return null;
	}

	public String display(final StoredLicense storedLicense) {
		final StringBuffer sb = new StringBuffer();

		sb.append("Licence Details - ");
		sb.append("getAdditionalInfo " + storedLicense.getAdditionalInfo());
		sb.append("\n");
		sb.append("\n");
		sb.append("getCustomerId " + storedLicense.getCustomerId());
		sb.append("\n");
		sb.append("getCustomerName " + storedLicense.getCustomerName());
		sb.append("\n");
		sb.append("getLicenseCode " + storedLicense.getLicenseCode());
		sb.append("\n");
		sb.append("\n");
		sb.append("getLicenseName " + storedLicense.getLicenseName());
		sb.append("\n");
		sb.append("\n");
		sb.append("getMaxValue " + storedLicense.getMaxValue());
		sb.append("\n");
		sb.append("getOrderId " + storedLicense.getOrderId());
		sb.append("\n");
		sb.append("getSerialNbr " + storedLicense.getSerialNbr());
		sb.append("\n");
		sb.append("\n");
		sb.append("\n");
		sb.append("getTargetNEType " + storedLicense.getTargetNEType());
		sb.append("\n");
		sb.append("\n");
		sb.append("\n");
		sb.append("getEndTime " + storedLicense.getEndTime());
		sb.append("\n");

		final int size = storedLicense.getFeatureInfoList().size();

		for (int i = 0; i < size; i++) {
			sb.append("Feature Code " + storedLicense.getFeatureInfoList().get(i).getFeatureCode() + "\n");
			sb.append("Feature Name " + storedLicense.getFeatureInfoList().get(i).getFeatureName() + "\n");
		}

		sb.append("\n");
		sb.append("getStartTime " + storedLicense.getStartTime());
		sb.append("\n");

		if (storedLicense.getTargetIds().listIterator().hasNext()) {
			sb.append("getTargetIds " + storedLicense.getTargetIds().listIterator().next());
		}

		sb.append(".");

		return sb.toString();
	}

	private boolean isFloating(final String usageType) {
		return ((usageType != null) && usageType.contains("Floating")) ? true : false;
	}
}
