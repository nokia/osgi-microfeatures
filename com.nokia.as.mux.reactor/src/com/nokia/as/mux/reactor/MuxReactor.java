package com.nokia.as.mux.reactor;

import java.io.IOException;
import java.util.concurrent.Callable;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.RunnableFuture;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.net.InetSocketAddress;
import org.apache.log4j.Logger;
import java.util.concurrent.ConcurrentHashMap;
import java.util.Collections;
import java.util.Map;

import com.alcatel.as.service.concurrent.ExecutorPolicy;
import com.alcatel.as.service.concurrent.PlatformExecutor;
import com.nextenso.mux.*;

import alcatel.tess.hometop.gateways.reactor.Reactor;
import alcatel.tess.hometop.gateways.reactor.util.SynchronousTimerTask;

public class MuxReactor implements Reactor {

	private static AtomicLong REACTOR_ID_SEED = new AtomicLong(1);
	private static AtomicLong CONN_ID_SEED = new AtomicLong(1L);

	//
	// NOTE : removed Meters in first version - re-add if needed
	//

	// Default logger used when no logger is provided when creating a Reactor.
	private final static Logger _defLogger = Logger.getLogger("as.service.reactor.mux.Reactor");

	// The Reactor logger
	private final Logger _logger;

	// Tells if our reactor is started.
	private final AtomicBoolean _started = new AtomicBoolean();

	// Our Reactor name (may be auto-generated if use does not provide one).
	private volatile String _name;

	// Flag telling if a name was given to our Reactor, during object creation.
	private final boolean _hasName;

	// Our Reactor provider impl
	private final MuxReactorProviderImpl _provider;

	// Executor used to dispatch input events to listener reactor thread.
	private final PlatformExecutor _queue;

	// Our worker thread queue
	private volatile Thread _threadQueue;

	// Latch used to shutdown the legacy run method, when the reactor is stopped.
	private final CountDownLatch _stopLatch = new CountDownLatch(1);

	private long _id, _idShifted;
	
    protected static final String PARAM_SECURE_DELAYED = "secure.delayed";

	/**
	 * Creates a new Reactor.
	 * 
	 * @param name     the reactor name. If null, then we'll create a unique name,
	 *                 but in this case, we won't use the meterng service (because
	 *                 we need a reactor name for the metering service.
	 * @param logger   The logger used by this reactor.
	 * @param provider the provided used to create this reacor
	 * @throws IOException if the reactor could not be properly initialized
	 */
	public MuxReactor(String name, Logger logger, final MuxReactorProviderImpl provider) throws IOException {
		logger = (logger == null) ? _defLogger : logger;
		_logger = logger;
		_provider = provider;

		_id = REACTOR_ID_SEED.getAndIncrement();

		// We only use the metering service if our reactor has a name.
		_hasName = (name != null);
		_name = (name == null) ? "Reactor-" + _id : name;

		// Initialize the default Reactor input handler thread
		_queue = _provider.getExecutors().createThreadQueueExecutor(name, new ThreadFactory() {
			@Override
			public Thread newThread(Runnable r) {
				return new Thread(r, _name + "-reactor");
			}
		});

		final CountDownLatch latch = new CountDownLatch(1);
		_queue.execute(new Runnable() {
			@Override
			public void run() {
				_threadQueue = Thread.currentThread();
				provider.setReactorThreadLocal(MuxReactor.this);
				latch.countDown();
			}
		});

		try {
			if (!latch.await(30000, TimeUnit.MILLISECONDS)) {
				throw new IOException("Could not initialize reactor executor thread");
			}
		} catch (InterruptedException e) {
			throw new IOException("could not initialize reactor executor", e);
		}

		_provider.registerReactor(_idShifted = _id << 32, this);
	}

	// ---------------- Reactor interface
	// ---------------------------------------------------

	/**
	 * Returns the name given to our Reactor during object creation. If null was
	 * given, then the name has been generated by our constructor and has the form
	 * "Reactor-Id". If no name was given, then the hasName() method returns false.
	 */
	public String getName() {
		return _name;
	}

	public boolean hasName() {
		return _hasName;
	}

	public void setName(String name) {
		if (name == null) {
			throw new IllegalArgumentException("a Reactor name can't be null");
		}
		_provider.aliasReactor(_name, null);
		_provider.aliasReactor(name, this);
		_name = name;
	}

	public void start() {
		if (!_started.compareAndSet(false, true)) {
			throw new IllegalStateException("reactor is already started");
		}
	}

	public void stop() {
		if (_logger.isInfoEnabled()) {
			_logger.info("Closing reactor " + _name);
		}

		_stopLatch.countDown(); // wake up legacy run method.
		_provider.aliasReactor(_name, null);
		_queue.shutdown();
		_provider.closeReactorChannels(this, false);
		_provider.unregisterReactor(_idShifted);
		_logger.info("Reactor " + _name + " closed");
	}

	public Logger getLogger() {
		return _logger;
	}

	public <T> Future<T> schedule(Callable<T> c) {
		return schedule(c, TaskPriority.DEFAULT);
	}

	public <T> Future<T> schedule(Callable<T> c, TaskPriority pri) {
		RunnableFuture<T> ftask = new FutureTask<T>(c);
		schedule(ftask, pri);
		return ftask;
	}

	public ScheduledFuture<?> schedule(final Runnable task, long delay, TimeUnit unit) {
		return _queue.schedule(task, delay, unit);
	}

	public ScheduledFuture<?> scheduleAtFixedRate(Runnable task, long initDelay, long delay, TimeUnit unit) {
		return _queue.scheduleAtFixedRate(task, initDelay, delay, unit);
	}

	public ScheduledFuture<?> scheduleWithFixedDelay(Runnable task, long initDelay, long delay, TimeUnit unit) {
		return _queue.scheduleWithFixedDelay(task, initDelay, delay, unit);
	}

	public <T> ScheduledFuture<T> schedule(Callable<T> callable, long delay, TimeUnit unit) {
		return _queue.schedule(callable, delay, unit);
	}

	@SuppressWarnings("deprecation")
	public void schedule(SynchronousTimerTask task, long delay) {
		throw new RuntimeException("Method not supported");
	}

	@SuppressWarnings("deprecation")
	public void schedule(SynchronousTimerTask task, long delay, long period) {
		throw new RuntimeException("Method not supported");
	}

	/**
	 * Schedules a task in the reactor thread, where application listeners are
	 * executed.
	 */
	public void execute(final Runnable task) {
		schedule(task, TaskPriority.DEFAULT);
	}

	/**
	 * Schedules a task in the reactor thread, where application listeners are
	 * executed.
	 */
	public void schedule(final Runnable task) {
		schedule(task, TaskPriority.DEFAULT);
	}

	public void schedule(final Runnable task, TaskPriority pri) {
		switch (pri) {
		case DEFAULT:
			_queue.execute(task, ExecutorPolicy.SCHEDULE);
			break;
		case HIGH:
			_queue.execute(task, ExecutorPolicy.SCHEDULE_HIGH);
			break;
		}
	}

	/**
	 * Schedules a task in the reactor thread, where application listeners are
	 * executed. If the current thread is the reactor thread, then the task is
	 * invoked in the context of the caller thread.
	 */
	public void scheduleNow(Runnable task) {
		scheduleNow(task, TaskPriority.DEFAULT);
	}

	public void scheduleNow(Runnable task, TaskPriority pri) {
		switch (pri) {
		case DEFAULT:
			_queue.execute(task, ExecutorPolicy.INLINE);
			break;
		case HIGH:
			_queue.execute(task, ExecutorPolicy.INLINE_HIGH);
			break;
		}
	}

	public Thread getReactorThread() {
		return _threadQueue;
	}

	public void close() {
		stop();
	}

	public void disconnect(final boolean abort) {
		_provider.closeReactorChannels(this, abort);
	}

	@SuppressWarnings("deprecation")
	public boolean cancel(SynchronousTimerTask task) {
		throw new RuntimeException("Method not supported");
	}

	/****************** Package methods **************************************/

	MuxReactorProviderImpl getReactorProvider() {
		return _provider;
	}

	boolean isStarted() {
		return _started.get();
	}

	@Override
	public PlatformExecutor getPlatformExecutor() {
		return _queue;
	}

	/**
	 * Legacy method, not used anymore (the start method should be used to start the
	 * reactor).
	 */
	@Override
	public void run() {
		if (!_started.compareAndSet(false, true)) {
			throw new IllegalStateException("Reactor " + _name + " already started");
		}

		try {
			_stopLatch.await();
		} catch (InterruptedException e) {
		}
	}

	/////// Mux methods

	protected MuxConnection muxConnection() {
		return _provider.muxConnection();
	}

	protected boolean tcpConnect(MuxTcpClientChannel channel) {
		long connectionId = CONN_ID_SEED.getAndIncrement() & 0xFF_FF_FF_FFL;
		connectionId |= _idShifted;
		InetSocketAddress to = channel.getRemoteAddress();
		InetSocketAddress from = channel.getLocalAddress();
		_provider.registerTcpConnect(connectionId, channel);
		
		_logger.debug("Performing sendTcpSocketConnect");

		Map<String,String> params = channel.isSecure() && channel.isDelayedSecureUpgrade() ?
				Collections.singletonMap(PARAM_SECURE_DELAYED, "1") : Collections.emptyMap();
		
		if (_provider.muxConnection().sendTcpSocketConnect(connectionId,
				to.getHostString(), to.getPort(),
				from != null ? from.getHostString() : null, 
				from != null ? from.getPort() : 0, channel.isSecure(),
				params)) {
			_logger.debug("sendTcpSocketConnect called");
			return true;
		} else {
			_logger.warn("sendTcpSocketConnect failed!");

			_provider.unregisterTcpConnect(connectionId);
			return false;
		}
	}
	
	@Override
	public String toString() {
		return "MuxReactor [_logger=" + _logger + ", _started=" + _started + ", _name=" + _name + ", _hasName="
				+ _hasName + ", _provider=" + _provider + ", _queue=" + _queue + ", _threadQueue=" + _threadQueue
				+ ", _stopLatch=" + _stopLatch + ", _id=" + _id + ", _idShifted=" + _idShifted + "]";
	}
}
